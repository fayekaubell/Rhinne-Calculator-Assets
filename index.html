<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallpaper Preview Calculator</title>
    <style>
        /* Reset and base styles - minimal to inherit from parent site */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Use system fonts to inherit better */
        body {
            font-family: inherit;
            line-height: 1.6;
            color: inherit;
            background: transparent;
        }

        /* Container matches your Shopify layout */
        .container {
            max-width: min(95vw, 1800px);
            margin: 0 auto;
            padding: 20px;
        }

        /* Page title section */
        .page-title {
            text-align: center;
            margin-bottom: 40px;
        }

        .page-title h1 {
            color: inherit;
            margin-bottom: 15px;
            font-size: 2rem;
            font-weight: normal;
        }

        .page-title p {
            margin: 0;
            opacity: 0.7;
            font-size: 16px;
        }

        /* Measuring guide - collapsible like your site */
        .measuring-guide {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .measuring-guide details {
            padding: 0;
        }

        .measuring-guide summary {
            padding: 20px 40px;
            cursor: pointer;
            list-style: none;
            border-radius: 12px;
            transition: background-color 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .measuring-guide summary h3 {
            margin: 0;
            color: inherit;
        }

        .measuring-guide summary:hover {
            background-color: rgba(248, 249, 250, 0.5);
        }

        .measuring-guide summary::-webkit-details-marker {
            display: none;
        }

        .measuring-guide summary::after {
            content: '+';
            font-size: 18px;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .measuring-guide details[open] summary::after {
            transform: rotate(45deg);
        }

        .guide-content {
            padding: 20px 40px 40px 40px;
            border-top: 1px solid rgba(233, 236, 239, 0.5);
        }

        .guide-content p {
            margin-bottom: 12px;
            line-height: 1.5;
            color: inherit;
        }

        .guide-content p:last-child {
            margin-bottom: 0;
            margin-top: 15px;
            font-style: italic;
            opacity: 0.8;
        }

        /* Calculator section */
        .calculator-section {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label,
        .form-group h3 {
            display: block;
            margin-bottom: 15px;
            color: inherit;
            font-size: inherit;
            font-weight: inherit;
            font-family: inherit;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid rgba(233, 236, 239, 0.8);
            border-radius: 8px;
            transition: border-color 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            font-family: inherit;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: rgba(108, 117, 125, 0.8);
        }

        .dimension-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .dimension-input input {
            flex: 1;
        }

        .dimension-input span {
            font-weight: 600;
            opacity: 0.7;
        }

        .btn {
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
            margin-top: 20px;
            font-size: 16px;
            font-weight: 600;
            background: rgba(108, 117, 125, 0.9);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            background: rgba(90, 98, 104, 0.9);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Preview section */
        .preview-section {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .title-container {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            display: block;
            clear: both;
        }

        .title-container h2 {
            margin: 0;
            padding: 0;
            display: block;
            width: 100%;
            color: inherit;
        }

        .canvas-container {
            text-align: center;
            margin: 30px 0;
            padding: 0;
            width: 100%;
            display: block;
            clear: both;
            position: relative;
        }

        #previewCanvas {
            border: 2px solid rgba(221, 221, 221, 0.8);
            border-radius: 8px;
            background: white;
            max-width: 100%;
            height: auto;
            cursor: zoom-in;
            display: block;
            margin: 0 auto;
        }

        #previewCanvas:hover {
            border-color: rgba(52, 152, 219, 0.8);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-weight: 600;
            color: inherit;
            text-align: center;
            width: 100%;
            height: 100%;
        }

        .preview-info {
            margin-top: 30px;
            text-align: center;
        }

        .preview-info h3 {
            margin-bottom: 15px;
            text-align: center;
            color: inherit;
        }

        .order-section {
            margin-bottom: 20px;
        }

        .order-line {
            margin-bottom: 8px;
            line-height: 1.4;
            text-align: center;
        }

        .divider {
            border: none;
            border-top: 1px solid rgba(233, 236, 239, 0.5);
            margin: 15px 0;
        }

        .disclaimer {
            margin: 15px 0;
            text-align: center;
        }

        .disclaimer p {
            margin: 0;
            font-style: italic;
            opacity: 0.8;
        }

        .form-error {
            color: #dc3545;
            font-style: italic;
            font-size: 14px;
            margin-top: 8px;
            padding: 5px 0;
        }

        .loading-message {
            text-align: center;
            padding: 20px;
            color: inherit;
            font-style: italic;
            opacity: 0.7;
        }

        .error-message {
            text-align: center;
            padding: 20px;
            color: #dc3545;
            background: rgba(248, 215, 218, 0.5);
            border: 1px solid rgba(245, 198, 203, 0.5);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .pattern-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            text-align: center;
        }

        /* Modal styles */
        .canvas-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px 0;
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }

        .canvas-modal canvas {
            cursor: zoom-out;
            border: 2px solid #fff;
            border-radius: 8px;
            margin: auto;
            display: block;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
                max-width: 95vw;
            }

            .calculator-section,
            .preview-section {
                padding: 25px;
            }

            .canvas-container {
                margin: 20px 0;
                padding: 0 10px;
            }

            #previewCanvas {
                max-width: calc(100vw - 50px);
                width: 100%;
                height: auto;
            }

            .dimension-input {
                flex-direction: column;
                align-items: stretch;
            }

            .btn {
                width: 100%;
            }
        }

        @media (min-width: 1200px) {
            .container {
                max-width: min(90vw, 2000px);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="page-title">
            <h1>Wallpaper Preview Calculator</h1>
            <p>Enter wall dimensions to estimate how much wallpaper you'll need. Visualize the pattern layout on your wall.</p>
        </div>

        <div class="measuring-guide">
            <details>
                <summary><h3>Measuring Guide</h3></summary>
                <div class="guide-content">
                    <p><strong>Standard Walls & Connected Walls</strong> Measure total width across all walls and height at the tallest point. Include doors, windows, and other obstacles in your measurements.</p>
                    <p><strong>Stairway Walls</strong> Measure width at the broadest section and height from the first floor to the maximum height.</p>
                    <p><strong>Ceilings</strong> Measure the shorter dimension for width and longer dimension for height.</p>
                    <p><strong>Sloped Ceiling Walls</strong> Measure full width and maximum height.</p>
                    <p><em>Note: Wallpaper projects can be tricky. Please don't hesitate to contact us for help with understanding measurements.</em></p>
                </div>
            </details>
        </div>

        <div class="calculator-section">
            <div id="loadingMessage" class="loading-message">
                Loading wallpaper patterns...
            </div>

            <div id="errorMessage" class="error-message" style="display: none;">
                Error loading patterns. Please refresh the page to try again.
            </div>

            <div id="calculatorForm" style="display: none;">
                <div class="form-group">
                    <h3>Select Wallpaper Pattern</h3>
                    <select id="pattern" required>
                        <option value="">Choose a pattern...</option>
                    </select>
                    <div class="pattern-info" id="patternInfo"></div>
                    <div class="form-error" id="patternError" style="display: none;">
                        <em>Please select a pattern</em>
                    </div>
                </div>

                <div class="form-group">
                    <h3>Wall Width</h3>
                    <div class="dimension-input">
                        <input type="number" id="widthFeet" placeholder="Feet" min="0" max="50">
                        <span>ft</span>
                        <input type="number" id="widthInches" placeholder="Inches" min="0" max="11" step="0.25" value="0">
                        <span>in</span>
                    </div>
                    <div class="form-error" id="widthError" style="display: none;">
                        <em>Please enter wall width</em>
                    </div>
                </div>

                <div class="form-group">
                    <h3>Wall Height</h3>
                    <div class="dimension-input">
                        <input type="number" id="heightFeet" placeholder="Feet" min="0" max="20">
                        <span>ft</span>
                        <input type="number" id="heightInches" placeholder="Inches" min="0" max="11" step="0.25" value="0">
                        <span>in</span>
                    </div>
                    <div class="form-error" id="heightError" style="display: none;">
                        <em>Please enter wall height</em>
                    </div>
                </div>

                <button type="button" class="btn" onclick="generatePreview()">Generate Preview</button>
            </div>
        </div>

        <div class="preview-section" id="previewSection">
            <div class="title-container">
                <h2 id="previewTitle">Pattern Preview</h2>
            </div>

            <div class="canvas-container">
                <canvas id="previewCanvas" width="1800" height="1400"></canvas>
                <div class="loading-overlay" id="loadingOverlay" style="display: none;">
                    Loading pattern...
                </div>
            </div>

            <div class="preview-info">
                <div class="order-section">
                    <h3>Estimated Quantity Required:</h3>
                    <div class="order-line">
                        <strong>Wall Dimensions:</strong> <span id="wallDimensions">-</span>
                    </div>
                    <div class="order-line">
                        <strong>Number of Strips:</strong> <span id="numStrips">-</span>
                    </div>
                    <div class="order-line">
                        <strong>Strip Length:</strong> <span id="stripLength">-</span>
                    </div>
                    <div class="order-line">
                        <strong>Total Yards:</strong> <span id="totalYards">-</span>
                    </div>
                </div>

                <hr class="divider">

                <div class="disclaimer">
                    <p><em>Results include 4" overage and account for pattern matching requirements.<br>
                    We recommend adding 10-20% additional overage to prevent installation issues.<br>
                    Please confirm requirements with your installer before ordering.</em></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Load pattern data -->
    <script src="patterns-data.js"></script>
    
    <script>
        // Global variables
        let currentPreview = null;
        let patternImage = null;
        let imageLoaded = false;

        // Initialize calculator when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing calculator...');
            
            // Check if pattern data is loaded
            if (typeof PATTERNS_DATA === 'undefined') {
                console.error('Pattern data not loaded');
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('errorMessage').style.display = 'block';
                return;
            }
            
            populatePatternDropdown();
        });

        // Populate the pattern dropdown and add change handler
        function populatePatternDropdown() {
            console.log('Populating pattern dropdown...');
            const select = document.getElementById('pattern');
            
            try {
                // Sort patterns alphabetically
                const sortedPatterns = [...PATTERNS_DATA].sort((a, b) => 
                    a.pattern_name.localeCompare(b.pattern_name)
                );
                
                sortedPatterns.forEach(pattern => {
                    const option = document.createElement('option');
                    option.value = pattern.sku;
                    option.textContent = pattern.pattern_name;
                    option.dataset.patternData = JSON.stringify(pattern);
                    select.appendChild(option);
                });
                
                console.log(`Added ${sortedPatterns.length} patterns to dropdown`);
                
                // Add change handler to show pattern info
                select.addEventListener('change', function() {
                    const patternInfo = document.getElementById('patternInfo');
                    if (this.value) {
                        const selectedOption = this.selectedOptions[0];
                        const pattern = JSON.parse(selectedOption.dataset.patternData);
                        patternInfo.textContent = `Repeat: ${pattern.repeat_width_inches}" × ${pattern.repeat_height_inches}" | Match: ${pattern.pattern_match} | Material width: ${pattern.material_width_inches}"`;
                    } else {
                        patternInfo.textContent = '';
                    }
                });
                
                // Hide loading message and show form
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('calculatorForm').style.display = 'block';
                
            } catch (error) {
                console.error('Error populating dropdown:', error);
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('errorMessage').style.display = 'block';
            }
        }

        // Load pattern image with fallback strategies
        function preloadPatternImage(pattern) {
            return new Promise((resolve) => {
                if (!pattern.repeat_url) {
                    console.log('No repeat URL provided for pattern');
                    resolve(null);
                    return;
                }

                console.log('Loading pattern image:', pattern.repeat_url);
                const img = new Image();
                
                img.onload = function() {
                    console.log('Pattern image loaded successfully');
                    patternImage = img;
                    imageLoaded = true;
                    resolve(img);
                };
                
                img.onerror = function() {
                    console.log('Image load failed, trying without CORS...');
                    
                    // Try without CORS
                    const fallbackImg = new Image();
                    fallbackImg.onload = function() {
                        console.log('Pattern image loaded without CORS');
                        patternImage = fallbackImg;
                        imageLoaded = true;
                        resolve(fallbackImg);
                    };
                    
                    fallbackImg.onerror = function() {
                        console.error('Failed to load pattern image:', pattern.repeat_url);
                        resolve(null);
                    };
                    
                    fallbackImg.src = pattern.repeat_url;
                };
                
                img.src = pattern.repeat_url;
            });
        }

        // Calculate wallpaper requirements - updated for proper overage handling
        function calculateYardRequirements(pattern, wallWidth, wallHeight) {
            // Add 4" overage to wall dimensions first
            const totalWidth = wallWidth + 4; // 4" horizontal overage
            const totalHeight = wallHeight + 4; // 4" vertical overage
            
            // Calculate number of strips needed based on material width
            const stripsNeeded = Math.ceil(totalWidth / pattern.material_width_inches);
            
            // Calculate strip length needed based on repeat height and pattern match
            let repeatsNeeded;
            if (pattern.pattern_match === 'half drop') {
                // For half drop, we need extra length for pattern matching
                repeatsNeeded = Math.ceil(totalHeight / pattern.repeat_height_inches) + 1;
            } else {
                // For straight match
                repeatsNeeded = Math.ceil(totalHeight / pattern.repeat_height_inches);
            }
            
            const stripLengthInches = repeatsNeeded * pattern.repeat_height_inches;
            
            // Calculate total yardage: (strip length × strips needed) / 36, rounded up, minimum from pattern
            const totalYardageRaw = (stripLengthInches * stripsNeeded) / 36;
            const totalYardage = Math.max(Math.ceil(totalYardageRaw), pattern.min_yard_order);
            
            return {
                stripsNeeded: stripsNeeded,
                stripLengthInches: stripLengthInches,
                stripLengthYards: Math.ceil(stripLengthInches / 36),
                totalYardage: totalYardage,
                totalWidth: stripsNeeded * pattern.material_width_inches,
                totalHeight: stripLengthInches
            };
        }

        // Main function to generate preview
        async function generatePreview() {
            try {
                console.log('Starting preview generation...');
                
                // Reset state
                currentPreview = null;
                patternImage = null;
                imageLoaded = false;
                
                document.getElementById('previewSection').style.display = 'none';
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Get form values
                const patternSelect = document.getElementById('pattern');
                const widthFeet = parseInt(document.getElementById('widthFeet').value) || 0;
                const widthInches = parseFloat(document.getElementById('widthInches').value) || 0;
                const heightFeet = parseInt(document.getElementById('heightFeet').value) || 0;
                const heightInches = parseFloat(document.getElementById('heightInches').value) || 0;
                
                // Validate inputs
                clearErrors();
                let hasErrors = false;
                
                if (!patternSelect.value) {
                    showError('patternError');
                    hasErrors = true;
                }
                
                if (widthFeet === 0 && widthInches === 0) {
                    showError('widthError');
                    hasErrors = true;
                }
                
                if (heightFeet === 0 && heightInches === 0) {
                    showError('heightError');
                    hasErrors = true;
                }
                
                if (hasErrors) return;
                
                // Get pattern data
                const selectedOption = patternSelect.selectedOptions[0];
                const pattern = JSON.parse(selectedOption.dataset.patternData);
                
                console.log('Selected pattern:', pattern.pattern_name);
                console.log('Pattern specs:', `${pattern.repeat_width_inches}" × ${pattern.repeat_height_inches}", ${pattern.pattern_match}`);
                
                // Convert dimensions to inches
                const wallWidth = (widthFeet * 12) + widthInches;
                const wallHeight = (heightFeet * 12) + heightInches;
                
                console.log(`Wall dimensions: ${wallWidth}" × ${wallHeight}"`);
                
                // Calculate requirements
                const calculations = calculateYardRequirements(pattern, wallWidth, wallHeight);
                
                console.log('Calculations:', calculations);
                
                // Format dimensions for display
                const formattedWidth = widthInches > 0 ? `${widthFeet}'${widthInches}"` : `${widthFeet}'`;
                const formattedHeight = heightInches > 0 ? `${heightFeet}'${heightInches}"` : `${heightFeet}'`;
                
                // Store current preview data
                currentPreview = {
                    pattern,
                    wallWidth,
                    wallHeight,
                    calculations,
                    formattedWidth,
                    formattedHeight
                };
                
                // Update title and show section
                document.getElementById('previewTitle').textContent = `${pattern.pattern_name} Preview`;
                document.getElementById('loadingOverlay').style.display = 'flex';
                document.getElementById('previewSection').style.display = 'block';
                document.getElementById('previewSection').scrollIntoView({ behavior: 'smooth' });
                
                // Load pattern image
                await preloadPatternImage(pattern);
                
                // Update results display
                updatePreviewInfo();
                
                // Draw the preview
                drawPreview();
                
                // Hide loading overlay
                document.getElementById('loadingOverlay').style.display = 'none';
                
                // Add click handler for modal (non-mobile only)
                const canvas = document.getElementById('previewCanvas');
                const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
                
                if (!isMobile) {
                    canvas.style.cursor = 'zoom-in';
                    canvas.onclick = openCanvasModal;
                } else {
                    canvas.style.cursor = 'default';
                    canvas.onclick = null;
                }
                
                console.log('Preview generation completed successfully');
                
            } catch (error) {
                console.error('Error in generatePreview:', error);
                document.getElementById('loadingOverlay').style.display = 'none';
                alert('An error occurred while generating the preview. Please try again.');
            }
        }

        function updatePreviewInfo() {
            const { calculations, formattedWidth, formattedHeight } = currentPreview;
            
            document.getElementById('wallDimensions').textContent = `${formattedWidth} × ${formattedHeight}`;
            document.getElementById('numStrips').textContent = calculations.stripsNeeded;
            document.getElementById('stripLength').textContent = `${calculations.stripLengthYards} yards each`;
            document.getElementById('totalYards').textContent = `${calculations.totalYardage} yards`;
        }

        function drawPreview() {
            console.log('Drawing three-section preview...');
            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            const { pattern, wallWidth, wallHeight, calculations } = currentPreview;
            
            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate dimensions for three sections with proper spacing
            const margin = 60;
            const sectionSpacing = 40; // Space between sections
            const availableWidth = canvas.width - (margin * 2);
            const availableHeight = canvas.height - (margin * 2) - (sectionSpacing * 2); // Remove spacing from available height
            
            // Section heights (flexible ratios)
            const section1Height = availableHeight * 0.25; // Top strips
            const section2Height = availableHeight * 0.45; // Overlaid on wall
            const section3Height = availableHeight * 0.25; // Wall only
            const arrowHeight = 30; // Fixed arrow height
            
            // Calculate scale to ensure everything fits within bounds
            const maxDisplayWidth = Math.max(calculations.totalWidth, wallWidth + 8); // 8" padding around wall
            const maxDisplayHeight = calculations.stripLengthInches;
            
            // Scale to fit both width and the largest section height
            const widthScale = availableWidth / maxDisplayWidth;
            const heightScale = section2Height / maxDisplayHeight; // Use section2 as it's the largest
            const scale = Math.min(widthScale, heightScale) * 0.9; // 90% to ensure some padding
            
            console.log(`Scale factor: ${scale.toFixed(3)}`);
            
            // Calculate section Y positions with proper spacing
            const section1Y = margin;
            const arrow1Y = section1Y + section1Height + sectionSpacing;
            const section2Y = arrow1Y + arrowHeight + sectionSpacing;
            const arrow2Y = section2Y + section2Height + sectionSpacing;
            const section3Y = arrow2Y + arrowHeight + sectionSpacing;
            
            // Draw sections with proper spacing
            drawSection1_Strips(ctx, margin, section1Y, availableWidth, section1Height, scale);
            drawArrows(ctx, margin, arrow1Y, availableWidth, arrowHeight);
            drawSection2_StripsOnWall(ctx, margin, section2Y, availableWidth, section2Height, scale);
            drawArrows(ctx, margin, arrow2Y, availableWidth, arrowHeight);
            drawSection3_WallOnly(ctx, margin, section3Y, availableWidth, section3Height, scale);
            
            console.log('Three-section preview completed');
        }

        // Section 1: Individual strips laid out horizontally
        function drawSection1_Strips(ctx, x, y, width, height, scale) {
            const { pattern, calculations } = currentPreview;
            
            const stripWidth = pattern.material_width_inches * scale;
            const stripHeight = calculations.stripLengthInches * scale;
            
            // Center strips horizontally in available width
            const totalStripsWidth = calculations.stripsNeeded * stripWidth;
            const startX = x + (width - totalStripsWidth) / 2;
            const centerY = y + height / 2;
            const stripY = centerY - stripHeight / 2;
            
            // Draw each strip
            for (let i = 0; i < calculations.stripsNeeded; i++) {
                const stripX = startX + (i * stripWidth);
                
                // Draw strip outline
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 0.6;
                ctx.strokeRect(stripX, stripY, stripWidth, stripHeight);
                
                // Draw pattern on strip
                drawPatternOnStrip(ctx, stripX, stripY, stripWidth, stripHeight, i, scale, 1.0);
            }
        }
        
        // Section 2: Strips overlaid on wall outline
        function drawSection2_StripsOnWall(ctx, x, y, width, height, scale) {
            const { pattern, wallWidth, wallHeight, calculations } = currentPreview;
            
            const stripWidth = pattern.material_width_inches * scale;
            const stripHeight = calculations.stripLengthInches * scale;
            const scaledWallWidth = wallWidth * scale;
            const scaledWallHeight = wallHeight * scale;
            
            // Center everything in available space
            const totalStripsWidth = calculations.stripsNeeded * stripWidth;
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            
            // Position strips (centered)
            const stripsStartX = centerX - totalStripsWidth / 2;
            const stripsStartY = centerY - stripHeight / 2;
            
            // Position wall (centered within strips)
            const wallStartX = centerX - scaledWallWidth / 2;
            const wallStartY = centerY - scaledWallHeight / 2;
            
            // Draw strips with patterns
            for (let i = 0; i < calculations.stripsNeeded; i++) {
                const stripX = stripsStartX + (i * stripWidth);
                
                // Draw strip outline
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 0.6;
                ctx.strokeRect(stripX, stripsStartY, stripWidth, stripHeight);
                
                // Draw pattern on strip with opacity based on wall overlap
                drawPatternOnStripWithWallMask(ctx, stripX, stripsStartY, stripWidth, stripHeight, i, scale, 
                                                wallStartX, wallStartY, scaledWallWidth, scaledWallHeight);
            }
            
            // Draw wall outline on top
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 0.6;
            ctx.strokeRect(wallStartX, wallStartY, scaledWallWidth, scaledWallHeight);
        }
        
        // Section 3: Wall dimensions only
        function drawSection3_WallOnly(ctx, x, y, width, height, scale) {
            const { wallWidth, wallHeight } = currentPreview;
            
            const scaledWallWidth = wallWidth * scale;
            const scaledWallHeight = wallHeight * scale;
            
            // Center wall in available space
            const wallX = x + (width - scaledWallWidth) / 2;
            const wallY = y + (height - scaledWallHeight) / 2;
            
            // Draw wall outline
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 0.6;
            ctx.strokeRect(wallX, wallY, scaledWallWidth, scaledWallHeight);
        }
        
        // Draw arrows between sections
        function drawArrows(ctx, x, y, width, height) {
            const arrowCount = 3;
            const arrowSpacing = width / (arrowCount + 1);
            const arrowSize = 8;
            const centerY = y + height / 2;
            
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 0.6;
            ctx.fillStyle = '#666666';
            
            for (let i = 1; i <= arrowCount; i++) {
                const arrowX = x + (i * arrowSpacing);
                
                // Draw arrow line
                ctx.beginPath();
                ctx.moveTo(arrowX, centerY - arrowSize);
                ctx.lineTo(arrowX, centerY + arrowSize);
                ctx.stroke();
                
                // Draw arrow head
                ctx.beginPath();
                ctx.moveTo(arrowX, centerY + arrowSize);
                ctx.lineTo(arrowX - arrowSize/2, centerY + arrowSize - arrowSize/2);
                ctx.lineTo(arrowX + arrowSize/2, centerY + arrowSize - arrowSize/2);
                ctx.closePath();
                ctx.fill();
            }
        }

        // Draw pattern on a single strip using clipping for seamless appearance
        function drawPatternOnStrip(ctx, stripX, stripY, stripWidth, stripHeight, stripIndex, scale, opacity) {
            const { pattern } = currentPreview;
            
            // Save context for clipping and opacity
            ctx.save();
            ctx.globalAlpha = opacity;
            
            // Clip to strip boundaries for seamless pattern
            ctx.beginPath();
            ctx.rect(stripX, stripY, stripWidth, stripHeight);
            ctx.clip();
            
            const repeatWidth = pattern.repeat_width_inches * scale;
            const repeatHeight = pattern.repeat_height_inches * scale;
            
            // Calculate how many repeats fit horizontally in the material width
            const horizontalRepeats = Math.ceil(pattern.material_width_inches / pattern.repeat_width_inches);
            
            // Calculate vertical offset for half-drop patterns
            let verticalOffset = 0;
            if (pattern.pattern_match === 'half drop' && stripIndex % 2 === 1) {
                verticalOffset = repeatHeight / 2;
            }
            
            // Draw pattern tiles to fill the strip - start from top-left and tile
            const tilesX = horizontalRepeats + 1; // Extra to ensure coverage
            const tilesY = Math.ceil((stripHeight + repeatHeight + Math.abs(verticalOffset)) / repeatHeight) + 1;
            
            for (let h = 0; h < tilesX; h++) {
                for (let v = 0; v < tilesY; v++) {
                    const tileX = stripX + (h * repeatWidth);
                    const tileY = stripY + (v * repeatHeight) - verticalOffset;
                    
                    if (imageLoaded && patternImage) {
                        try {
                            ctx.drawImage(patternImage, tileX, tileY, repeatWidth, repeatHeight);
                        } catch (error) {
                            drawFallbackTile(ctx, tileX, tileY, repeatWidth, repeatHeight, h, v);
                        }
                    } else {
                        drawFallbackTile(ctx, tileX, tileY, repeatWidth, repeatHeight, h, v);
                    }
                }
            }
            
            ctx.restore();
        }
        
        // Draw pattern on strip with wall mask for section 2 using clipping
        function drawPatternOnStripWithWallMask(ctx, stripX, stripY, stripWidth, stripHeight, stripIndex, scale, wallX, wallY, wallWidth, wallHeight) {
            const { pattern } = currentPreview;
            
            // First draw the part inside the wall at full opacity
            ctx.save();
            ctx.globalAlpha = 1.0;
            
            // Clip to intersection of strip and wall
            ctx.beginPath();
            const intersectX = Math.max(stripX, wallX);
            const intersectY = Math.max(stripY, wallY);
            const intersectW = Math.min(stripX + stripWidth, wallX + wallWidth) - intersectX;
            const intersectH = Math.min(stripY + stripHeight, wallY + wallHeight) - intersectY;
            
            if (intersectW > 0 && intersectH > 0) {
                ctx.rect(intersectX, intersectY, intersectW, intersectH);
                ctx.clip();
                drawPatternTiles(ctx, stripX, stripY, stripWidth, stripHeight, stripIndex, scale);
            }
            ctx.restore();
            
            // Then draw the part outside the wall at 50% opacity
            ctx.save();
            ctx.globalAlpha = 0.5;
            
            // Clip to strip minus wall area
            ctx.beginPath();
            ctx.rect(stripX, stripY, stripWidth, stripHeight);
            if (intersectW > 0 && intersectH > 0) {
                // Subtract the wall intersection area
                ctx.rect(intersectX, intersectY, intersectW, intersectH);
                ctx.clip('evenodd'); // Use even-odd rule to subtract
            } else {
                ctx.clip();
            }
            
            drawPatternTiles(ctx, stripX, stripY, stripWidth, stripHeight, stripIndex, scale);
            ctx.restore();
        }
        
        // Helper function to draw pattern tiles without clipping
        function drawPatternTiles(ctx, stripX, stripY, stripWidth, stripHeight, stripIndex, scale) {
            const { pattern } = currentPreview;
            
            const repeatWidth = pattern.repeat_width_inches * scale;
            const repeatHeight = pattern.repeat_height_inches * scale;
            
            // Calculate how many repeats fit horizontally in the material width
            const horizontalRepeats = Math.ceil(pattern.material_width_inches / pattern.repeat_width_inches);
            
            // Calculate vertical offset for half-drop patterns
            let verticalOffset = 0;
            if (pattern.pattern_match === 'half drop' && stripIndex % 2 === 1) {
                verticalOffset = repeatHeight / 2;
            }
            
            // Draw pattern tiles to fill the strip
            const tilesX = horizontalRepeats + 1;
            const tilesY = Math.ceil((stripHeight + repeatHeight + Math.abs(verticalOffset)) / repeatHeight) + 1;
            
            for (let h = 0; h < tilesX; h++) {
                for (let v = 0; v < tilesY; v++) {
                    const tileX = stripX + (h * repeatWidth);
                    const tileY = stripY + (v * repeatHeight) - verticalOffset;
                    
                    if (imageLoaded && patternImage) {
                        try {
                            ctx.drawImage(patternImage, tileX, tileY, repeatWidth, repeatHeight);
                        } catch (error) {
                            drawFallbackTile(ctx, tileX, tileY, repeatWidth, repeatHeight, h, v);
                        }
                    } else {
                        drawFallbackTile(ctx, tileX, tileY, repeatWidth, repeatHeight, h, v);
                    }
                }
            }
        }

        function drawFallbackTile(ctx, x, y, width, height, i, j) {
            // Create a simple pattern as fallback with pattern name
            const colors = ['#f8f9fa', '#e9ecef', '#dee2e6', '#ced4da'];
            const colorIndex = (i + j) % colors.length;
            
            ctx.fillStyle = colors[colorIndex];
            ctx.fillRect(x, y, width, height);
            
            // No stroke for seamless appearance
            
            // Add pattern info text if tile is large enough
            if (width > 40 && height > 20) {
                ctx.fillStyle = '#6c757d';
                ctx.font = `${Math.min(12, width/8)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(currentPreview.pattern.pattern_name.split(':')[0], x + width/2, y + height/2);
            }
        }

        function openCanvasModal() {
            console.log('Canvas modal - full size view (to be implemented)');
            // Modal functionality can be added here if needed
        }

        // Utility functions
        function showError(elementId) {
            document.getElementById(elementId).style.display = 'block';
        }

        function clearErrors() {
            const errors = document.querySelectorAll('.form-error');
            errors.forEach(error => error.style.display = 'none');
        }
    </script>
</body>
</html>
